<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ğŸ«§ BLOB PARTY!</title>
<link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@400;700;900&display=swap" rel="stylesheet">
<style>
:root {
  --pink: #ff4d8d;
  --yellow: #ffe135;
  --cyan: #00e5ff;
  --purple: #b44dff;
  --green: #4dff91;
  --orange: #ff8c1a;
  --bg: #1a0a2e;
  --panel: #2a1545;
  --panel2: #1f0f38;
}
* { margin:0; padding:0; box-sizing:border-box; }
body {
  background: var(--bg);
  font-family: 'Nunito', sans-serif;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  color: white;
  user-select: none;
}

/* CONFETTI */
.confetti-piece {
  position: fixed;
  width: 10px; height: 10px;
  top: -20px;
  animation: confettiFall linear forwards;
  border-radius: 2px;
  z-index: 9999;
  pointer-events: none;
}
@keyframes confettiFall {
  to { transform: translateY(110vh) rotate(720deg); opacity: 0; }
}

/* â”€â”€ SCREENS â”€â”€ */
.screen { display:none; width:100vw; height:100vh; position:absolute; top:0; left:0; }
.screen.active { display:flex; flex-direction:column; align-items:center; justify-content:center; }

/* â•â•â•â•â•â•â•â•â•â•â• TITLE SCREEN â•â•â•â•â•â•â•â•â•â•â• */
#screen-title {
  background: radial-gradient(ellipse at 50% 30%, #3d0f6b 0%, #1a0a2e 70%);
}
.title-blob {
  font-family: 'Fredoka One', cursive;
  font-size: clamp(48px, 10vw, 96px);
  background: linear-gradient(135deg, var(--pink), var(--yellow), var(--cyan), var(--purple));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  animation: titlePulse 2s ease-in-out infinite;
  text-shadow: none;
  filter: drop-shadow(0 0 30px rgba(255,100,200,0.5));
}
@keyframes titlePulse {
  0%,100% { transform: scale(1) rotate(-1deg); }
  50% { transform: scale(1.05) rotate(1deg); }
}
.title-sub {
  font-size: 18px;
  color: #b0a0cc;
  margin: 8px 0 40px;
  letter-spacing: 3px;
  text-transform: uppercase;
}
.blobs-preview {
  display: flex;
  gap: 12px;
  margin-bottom: 36px;
  flex-wrap: wrap;
  justify-content: center;
}
.big-btn {
  background: linear-gradient(135deg, var(--pink), var(--purple));
  border: none;
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 28px;
  padding: 18px 60px;
  border-radius: 50px;
  cursor: pointer;
  box-shadow: 0 8px 30px rgba(255,77,141,0.5), 0 0 0 4px rgba(255,255,255,0.1);
  transition: all 0.15s;
  letter-spacing: 2px;
}
.big-btn:hover { transform: translateY(-3px) scale(1.04); box-shadow: 0 14px 40px rgba(255,77,141,0.7); }
.big-btn:active { transform: translateY(1px) scale(0.98); }
.big-btn.green { background: linear-gradient(135deg, #00c853, var(--green)); box-shadow: 0 8px 30px rgba(0,220,100,0.5), 0 0 0 4px rgba(255,255,255,0.1); }
.big-btn.cyan { background: linear-gradient(135deg, #0077ff, var(--cyan)); box-shadow: 0 8px 30px rgba(0,180,255,0.5), 0 0 0 4px rgba(255,255,255,0.1); }

/* â•â•â•â•â•â•â•â•â•â•â• LOBBY / JOIN â•â•â•â•â•â•â•â•â•â•â• */
#screen-join { background: radial-gradient(ellipse at 50% 50%, #0d1f3d 0%, #1a0a2e 80%); }
.join-card {
  background: var(--panel);
  border-radius: 28px;
  padding: 40px;
  width: min(480px, 92vw);
  border: 2px solid rgba(255,255,255,0.08);
  box-shadow: 0 20px 60px rgba(0,0,0,0.5);
}
.join-title {
  font-family: 'Fredoka One', cursive;
  font-size: 36px;
  text-align: center;
  margin-bottom: 28px;
  color: var(--yellow);
}
.name-input {
  width: 100%;
  background: rgba(255,255,255,0.07);
  border: 2px solid rgba(255,255,255,0.15);
  border-radius: 16px;
  padding: 16px 20px;
  font-size: 22px;
  font-family: 'Fredoka One', cursive;
  color: white;
  outline: none;
  text-align: center;
  transition: border-color 0.2s;
  margin-bottom: 20px;
}
.name-input:focus { border-color: var(--cyan); }
.name-input::placeholder { color: rgba(255,255,255,0.3); }
.color-pick {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  margin-bottom: 24px;
}
.color-swatch {
  width: 44px; height: 44px;
  border-radius: 50%;
  cursor: pointer;
  border: 3px solid transparent;
  transition: all 0.15s;
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
}
.color-swatch:hover { transform: scale(1.2); }
.color-swatch.chosen { border-color: white; transform: scale(1.25); box-shadow: 0 0 0 3px white, 0 6px 16px rgba(0,0,0,0.5); }
.room-code-display {
  background: rgba(255,255,255,0.05);
  border-radius: 16px;
  padding: 14px;
  text-align: center;
  margin-bottom: 20px;
  font-family: 'Fredoka One', cursive;
  font-size: 32px;
  letter-spacing: 8px;
  color: var(--yellow);
  border: 2px dashed rgba(255,225,53,0.3);
}
.room-label { font-size: 11px; letter-spacing: 3px; color: #8070aa; text-transform: uppercase; margin-bottom: 4px; }

/* â•â•â•â•â•â•â•â•â•â•â• LOBBY WAITING â•â•â•â•â•â•â•â•â•â•â• */
#screen-lobby { background: radial-gradient(ellipse at 50% 50%, #0d2030 0%, #1a0a2e 80%); flex-direction: column; }
.lobby-header {
  font-family: 'Fredoka One', cursive;
  font-size: 36px;
  color: var(--cyan);
  margin-bottom: 6px;
}
.lobby-code { font-size: 14px; color: #8070aa; letter-spacing: 3px; margin-bottom: 30px; }
.players-grid {
  display: grid;
  grid-template-columns: repeat(6, 1fr);
  gap: 14px;
  width: min(780px, 95vw);
  margin-bottom: 28px;
}
.player-slot {
  background: rgba(255,255,255,0.04);
  border: 2px dashed rgba(255,255,255,0.1);
  border-radius: 18px;
  padding: 16px 8px;
  text-align: center;
  transition: all 0.3s;
  min-height: 110px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
}
.player-slot.filled {
  background: rgba(255,255,255,0.06);
  border-color: rgba(255,255,255,0.2);
  animation: slotPop 0.4s ease;
}
@keyframes slotPop { 0% { transform: scale(0.7); } 70% { transform: scale(1.1); } 100% { transform: scale(1); } }
.slot-name { font-size: 12px; font-weight: 700; margin-top: 6px; word-break: break-word; }
.slot-badge { font-size: 10px; color: var(--yellow); margin-top: 2px; }
.lobby-status { font-size: 15px; color: #8070aa; margin-bottom: 20px; }
.btn-row { display:flex; gap:14px; flex-wrap:wrap; justify-content:center; }
.sm-btn {
  background: rgba(255,255,255,0.08);
  border: 2px solid rgba(255,255,255,0.15);
  color: white;
  font-family: 'Fredoka One', cursive;
  font-size: 18px;
  padding: 12px 32px;
  border-radius: 40px;
  cursor: pointer;
  transition: all 0.15s;
}
.sm-btn:hover { background: rgba(255,255,255,0.15); transform: translateY(-2px); }

/* â•â•â•â•â•â•â•â•â•â•â• GAME SCREEN â•â•â•â•â•â•â•â•â•â•â• */
#screen-game {
  background: #0d0d1e;
  flex-direction: row;
  align-items: stretch;
  justify-content: flex-start;
  overflow: hidden;
}
#game-canvas { flex: 1; display:block; }
#sidebar {
  width: 220px;
  background: var(--panel2);
  border-left: 2px solid rgba(255,255,255,0.06);
  display: flex;
  flex-direction: column;
  padding: 16px;
  gap: 10px;
  overflow-y: auto;
}
.sidebar-title {
  font-family: 'Fredoka One', cursive;
  font-size: 18px;
  color: var(--yellow);
  border-bottom: 2px solid rgba(255,255,255,0.08);
  padding-bottom: 8px;
}
.player-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 8px 10px;
  border-radius: 12px;
  background: rgba(255,255,255,0.04);
  font-size: 13px;
  font-weight: 700;
  transition: all 0.3s;
}
.player-row.is-out { opacity: 0.35; text-decoration: line-through; }
.player-row.is-impostor { background: rgba(255,50,50,0.15); }
.mini-blob { width:28px; height:28px; border-radius:50%; flex-shrink:0; }
.task-bar-wrap { background: rgba(0,0,0,0.3); border-radius: 8px; height: 6px; margin-top: 3px; overflow:hidden; }
.task-bar-fill { height:100%; border-radius:8px; background: linear-gradient(90deg, var(--green), var(--cyan)); transition: width 0.4s; }
.game-phase-banner {
  position:absolute; top:16px; left:50%; transform:translateX(-50%);
  background: rgba(0,0,0,0.7);
  border-radius: 40px;
  padding: 10px 28px;
  font-family: 'Fredoka One', cursive;
  font-size: 22px;
  color: var(--yellow);
  pointer-events:none;
  z-index: 50;
  border: 2px solid rgba(255,225,53,0.3);
  white-space: nowrap;
}

/* â•â•â•â•â•â•â•â•â•â•â• TASK POPUP â•â•â•â•â•â•â•â•â•â•â• */
#task-popup {
  display:none;
  position:fixed; inset:0; z-index:200;
  background: rgba(0,0,0,0.75);
  align-items:center; justify-content:center;
}
#task-popup.show { display:flex; }
.task-card {
  background: var(--panel);
  border-radius: 28px;
  padding: 36px;
  width: min(500px, 95vw);
  border: 3px solid var(--cyan);
  box-shadow: 0 0 60px rgba(0,229,255,0.3);
  text-align:center;
}
.task-card h2 { font-family:'Fredoka One',cursive; font-size:28px; color:var(--cyan); margin-bottom:16px; }
.task-card p { color:#b0c0dd; margin-bottom:24px; font-size:16px; }

/* â•â•â•â•â•â•â•â•â•â•â• VOTE POPUP â•â•â•â•â•â•â•â•â•â•â• */
#vote-popup {
  display:none;
  position:fixed; inset:0; z-index:300;
  background: rgba(0,0,0,0.88);
  align-items:center; justify-content:center;
  flex-direction:column;
}
#vote-popup.show { display:flex; }
.vote-header {
  font-family:'Fredoka One',cursive;
  font-size:42px;
  color:var(--pink);
  margin-bottom:8px;
  text-shadow: 0 0 30px var(--pink);
  animation: shake 0.5s ease;
}
@keyframes shake {
  0%,100%{transform:rotate(0)} 25%{transform:rotate(-3deg)} 75%{transform:rotate(3deg)}
}
.vote-sub { color:#8070aa; font-size:14px; margin-bottom:30px; letter-spacing:2px; }
.vote-grid { display:flex; gap:14px; flex-wrap:wrap; justify-content:center; max-width:700px; }
.vote-card {
  background: rgba(255,255,255,0.06);
  border: 3px solid rgba(255,255,255,0.12);
  border-radius: 20px;
  padding: 20px 16px;
  width: 110px;
  text-align:center;
  cursor:pointer;
  transition: all 0.2s;
  position:relative;
}
.vote-card:hover { background:rgba(255,255,255,0.14); transform:scale(1.08); border-color:var(--yellow); }
.vote-card.voted-for { border-color:var(--pink); background:rgba(255,77,141,0.2); transform:scale(1.08); }
.vote-card.skip-card { border-color:rgba(180,180,180,0.3); }
.vote-card .vname { font-family:'Fredoka One',cursive; font-size:13px; margin-top:8px; word-break:break-word; }
.vote-count-badge {
  position:absolute; top:-8px; right:-8px;
  background:var(--pink); color:white;
  font-size:11px; font-weight:900;
  border-radius:20px; padding:2px 8px;
  display:none;
}
.vote-count-badge.show { display:block; }
.vote-timer { font-family:'Fredoka One',cursive; font-size:48px; color:var(--yellow); margin-top:20px; }

/* â•â•â•â•â•â•â•â•â•â•â• RESULT SCREEN â•â•â•â•â•â•â•â•â•â•â• */
#screen-result { background: radial-gradient(ellipse at 50% 40%, #1a0030 0%, #0a0018 80%); }
.result-title { font-family:'Fredoka One',cursive; font-size:clamp(36px,8vw,72px); margin-bottom:16px; }
.result-title.crewwin { color:var(--cyan); text-shadow:0 0 40px var(--cyan); }
.result-title.impwin { color:var(--pink); text-shadow:0 0 40px var(--pink); }
.result-reveal { font-size:22px; color:#c0b0dd; margin-bottom:30px; }
.result-impostors { display:flex; gap:20px; justify-content:center; flex-wrap:wrap; margin-bottom:36px; }
.result-blob-card {
  background:rgba(255,255,255,0.06); border-radius:20px; padding:20px 24px; text-align:center;
  border: 2px solid rgba(255,77,141,0.4);
}
.result-blob-card .rname { font-family:'Fredoka One',cursive; font-size:18px; margin-top:8px; }
.result-stats { font-size:14px; color:#706090; margin-bottom:32px; }

/* â•â•â•â•â•â•â•â•â•â•â• MINI TASK GAMES â•â•â•â•â•â•â•â•â•â•â• */
.task-game { margin-top:10px; }
/* Color match */
.color-match-grid { display:grid; grid-template-columns:repeat(4,1fr); gap:10px; margin-top:10px; }
.cm-cell {
  height:60px; border-radius:12px; cursor:pointer; transition:all 0.15s;
  border:3px solid transparent;
}
.cm-cell:hover { transform:scale(1.08); border-color:white; }
/* Simon Says buttons */
.simon-grid { display:grid; grid-template-columns:repeat(2,1fr); gap:12px; margin-top:10px; }
.simon-btn {
  height:80px; border-radius:16px; cursor:pointer;
  font-family:'Fredoka One',cursive; font-size:20px;
  border:4px solid rgba(255,255,255,0.2);
  transition:all 0.15s;
  opacity:0.5;
}
.simon-btn.lit { opacity:1; transform:scale(1.05); box-shadow:0 0 30px currentColor; }
/* Whack task */
.whack-grid { display:grid; grid-template-columns:repeat(3,1fr); gap:8px; margin-top:10px; }
.whack-hole {
  height:64px; border-radius:14px;
  background:rgba(0,0,0,0.4);
  border:2px solid rgba(255,255,255,0.08);
  display:flex; align-items:center; justify-content:center;
  font-size:30px; cursor:pointer;
  transition:all 0.15s;
}
.whack-hole:hover { background:rgba(255,255,255,0.08); }
/* Wire task */
.wire-area { display:flex; justify-content:space-between; align-items:center; gap:20px; margin-top:10px; }
.wire-col { display:flex; flex-direction:column; gap:10px; }
.wire-node {
  width:36px; height:36px; border-radius:50%;
  cursor:pointer; border:3px solid rgba(255,255,255,0.3);
  display:flex; align-items:center; justify-content:center;
  font-weight:900; font-size:13px;
  transition:all 0.2s;
}
.wire-node:hover { transform:scale(1.2); border-color:white; }
.wire-node.selected { border-color:white; transform:scale(1.2); box-shadow:0 0 16px white; }
.wire-canvas-wrap { position:relative; flex:1; height:160px; }
#wireCanvas { position:absolute; top:0; left:0; }

/* SABOTAGE FLASH */
#sabotage-overlay {
  display:none; position:fixed; inset:0; z-index:400;
  background:rgba(255,0,50,0.0);
  pointer-events:none;
}
#sabotage-overlay.flash { display:block; animation: sabFlash 0.8s ease; }
@keyframes sabFlash {
  0%{background:rgba(255,0,50,0)}
  30%{background:rgba(255,0,50,0.4)}
  100%{background:rgba(255,0,50,0)}
}

/* KILL ANIMATION */
.kill-flash { position:fixed; inset:0; background:rgba(200,0,30,0.6); z-index:500; pointer-events:none; animation:killFlash 0.6s ease forwards; }
@keyframes killFlash { to{opacity:0} }

/* TOAST */
#toast { position:fixed; bottom:80px; left:50%; transform:translateX(-50%); z-index:600; pointer-events:none; }
.toast-msg {
  background:rgba(0,0,0,0.85); color:white; padding:12px 28px;
  border-radius:40px; font-family:'Fredoka One',cursive; font-size:18px;
  margin-bottom:8px; animation:toastIn 0.3s ease, toastOut 0.3s ease 2s forwards;
  white-space:nowrap;
}
@keyframes toastIn{from{opacity:0;transform:translateY(20px)}to{opacity:1;transform:translateY(0)}}
@keyframes toastOut{to{opacity:0;transform:translateY(-10px)}}

/* GHOST */
.player-row.ghost-style { opacity:0.35; }
</style>
</head>
<body>

<!-- â•â•â•â•â•â•â•â•â•â• TITLE SCREEN â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-title" class="screen active">
  <div class="title-blob">ğŸ«§ BLOB PARTY!</div>
  <div class="title-sub">The silliest impostor game ever</div>
  <div class="blobs-preview" id="previewBlobs"></div>
  <div style="display:flex;gap:16px;flex-wrap:wrap;justify-content:center;">
    <button class="big-btn" onclick="showCreateRoom()">ğŸ‰ HOST GAME</button>
    <button class="big-btn cyan" onclick="showJoinRoom()">ğŸš€ JOIN GAME</button>
  </div>
  <div style="margin-top:24px;font-size:13px;color:#504070;letter-spacing:2px;">UP TO 12 PLAYERS â€¢ SAME DEVICE OR SHARE THE LINK</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• JOIN / CREATE SCREEN â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-join" class="screen">
  <div class="join-card">
    <div class="join-title" id="join-title">ğŸ‰ Host a Game!</div>
    <div class="room-label">Your Name</div>
    <input class="name-input" id="nameInput" placeholder="Enter name..." maxlength="14" autocomplete="off">
    <div class="room-label">Pick your color</div>
    <div class="color-pick" id="colorPick"></div>
    <div id="join-code-section" style="display:none">
      <div class="room-label">Room Code</div>
      <input class="name-input" id="codeInput" placeholder="ABC123" maxlength="6" style="letter-spacing:4px;text-transform:uppercase">
    </div>
    <div style="display:flex;gap:12px;justify-content:center;margin-top:8px;">
      <button class="big-btn green" id="joinBtn" onclick="enterLobby()">Let's Go! ğŸš€</button>
      <button class="sm-btn" onclick="showScreen('screen-title')">Back</button>
    </div>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• LOBBY SCREEN â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-lobby" class="screen">
  <div class="lobby-header">ğŸ® Waiting Room</div>
  <div class="lobby-code">Room Code: <strong id="lobby-code-display" style="color:var(--yellow);letter-spacing:4px;font-size:18px;"></strong></div>
  <div class="players-grid" id="playersGrid"></div>
  <div class="lobby-status" id="lobbyStatus"></div>
  <div class="btn-row">
    <button class="big-btn green" id="startBtn" onclick="startGame()" style="display:none">â–¶ START GAME!</button>
    <button class="sm-btn" id="waitMsg">Waiting for host...</button>
    <button class="sm-btn" onclick="leaveLobby()">ğŸšª Leave</button>
  </div>
  <div style="margin-top:16px;font-size:12px;color:#403060;">Share the room code with friends on the same device!</div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• GAME SCREEN â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-game" class="screen" style="position:relative;">
  <canvas id="game-canvas"></canvas>
  <div id="sidebar">
    <div class="sidebar-title">ğŸ«§ Players</div>
    <div id="playerList"></div>
    <div style="margin-top:auto;">
      <div class="sidebar-title" style="margin-top:12px;">ğŸ“‹ Tasks</div>
      <div id="taskProgress" style="font-size:12px;color:#8070aa;margin-top:6px;"></div>
      <div class="task-bar-wrap" style="margin-top:8px;">
        <div class="task-bar-fill" id="globalTaskBar" style="width:0%"></div>
      </div>
    </div>
    <div style="margin-top:16px;display:flex;flex-direction:column;gap:8px;">
      <button class="sm-btn" style="font-size:14px;" onclick="openTask()">ğŸ“‹ Do Task</button>
      <button class="sm-btn" style="font-size:14px;border-color:rgba(255,100,0,0.4);color:var(--orange);" onclick="callMeeting()">ğŸš¨ Meeting!</button>
      <button class="sm-btn" id="killBtn" style="font-size:14px;border-color:rgba(255,50,50,0.4);color:#ff5555;display:none;" onclick="performKill()">ğŸ’€ ELIMINATE</button>
    </div>
  </div>
  <div class="game-phase-banner" id="phaseBanner"></div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• RESULT SCREEN â•â•â•â•â•â•â•â•â•â• -->
<div id="screen-result" class="screen">
  <div class="result-title" id="resultTitle"></div>
  <div class="result-reveal" id="resultReveal"></div>
  <div class="result-impostors" id="resultImpostors"></div>
  <div class="result-stats" id="resultStats"></div>
  <div style="display:flex;gap:14px;flex-wrap:wrap;justify-content:center;">
    <button class="big-btn" onclick="playAgain()">ğŸ” Play Again</button>
    <button class="sm-btn" onclick="showScreen('screen-title')">ğŸ  Home</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• TASK POPUP â•â•â•â•â•â•â•â•â•â• -->
<div id="task-popup">
  <div class="task-card">
    <h2 id="taskTitle">Task</h2>
    <p id="taskDesc"></p>
    <div id="taskGameArea" class="task-game"></div>
    <button class="sm-btn" style="margin-top:16px;" onclick="closeTask()">âŒ Cancel</button>
  </div>
</div>

<!-- â•â•â•â•â•â•â•â•â•â• VOTE POPUP â•â•â•â•â•â•â•â•â•â• -->
<div id="vote-popup">
  <div class="vote-header">ğŸš¨ EMERGENCY MEETING!</div>
  <div class="vote-sub" id="voteSubtitle">Who is the impostor? Vote now!</div>
  <div class="vote-grid" id="voteGrid"></div>
  <div class="vote-timer" id="voteTimerDisplay">30</div>
  <div style="margin-top:12px;font-size:13px;color:#605080;" id="voteStatusMsg"></div>
</div>

<!-- OVERLAYS -->
<div id="sabotage-overlay"></div>
<div id="toast"></div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ğŸ«§ BLOB PARTY â€” Full multiplayer party game
//  Uses BroadcastChannel for real cross-tab communication!
//  All 12 players can join from different browser tabs.
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”€â”€ CONSTANTS â”€â”€
const BLOB_COLORS = [
  '#FF4D8D','#FF8C1A','#FFE135','#4DFF91','#00E5FF',
  '#4D79FF','#B44DFF','#FF4D4D','#FFFFFF','#00FFB3',
  '#FF6ECC','#A0FF4D'
];
const COLOR_NAMES = [
  'Pink','Orange','Yellow','Green','Cyan',
  'Blue','Purple','Red','White','Mint',
  'Rose','Lime'
];
const MAP_W = 1800, MAP_H = 1200;
const TASK_DEFS = [
  { id:'wire',   name:'Fix the Wires',    desc:'Connect matching colored wires!', emoji:'âš¡' },
  { id:'simon',  name:'Simon Says!',      desc:'Repeat the light pattern!',       emoji:'ğŸŸ©' },
  { id:'whack',  name:'Whack the Blobs!', desc:'Tap the blobs as fast as you can!',emoji:'ğŸ”¨' },
  { id:'color',  name:'Color Match!',     desc:'Tap the correct color!',          emoji:'ğŸ¨' },
];
const TASKS_PER_PLAYER = 3;
const IMPOSTOR_COUNT = { 4:1, 5:1, 6:1, 7:2, 8:2, 9:2, 10:2, 11:3, 12:3 };
const VOTE_TIME = 30;
const KILL_COOLDOWN = 25;
const MOVE_SPEED = 4;

// â”€â”€ STATE â”€â”€
let myId = null;
let myName = '';
let myColor = 0;
let isHost = false;
let isImpostor = false;
let roomCode = '';
let gameState = null; // shared state
let channel = null;   // BroadcastChannel
let localPlayer = null;
let gameLoop = null;
let keys = {};
let voteTimer = null;
let voteTimeLeft = VOTE_TIME;
let killCooldownLeft = 0;
let myVote = null;
let tasksDone = [];
let currentTask = null;
let animFrame = null;
let canvas, ctx;
let cameraX = 0, cameraY = 0;
let meetingCaller = null;

// â”€â”€ ROOMS (stored in sessionStorage, broadcast via BroadcastChannel) â”€â”€
function getRoom() {
  try { return JSON.parse(sessionStorage.getItem('blobparty_' + roomCode) || 'null'); } catch(e){ return null; }
}
function setRoom(data) {
  sessionStorage.setItem('blobparty_' + roomCode, JSON.stringify(data));
  if (channel) channel.postMessage({ type: 'stateUpdate', roomCode, data });
}
function genRoomCode() {
  const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i=0;i<6;i++) code += chars[Math.floor(Math.random()*chars.length)];
  return code;
}

// â”€â”€ BROADCAST CHANNEL â”€â”€
function setupChannel() {
  if (channel) channel.close();
  channel = new BroadcastChannel('blobparty_channel');
  channel.onmessage = (e) => {
    const msg = e.data;
    if (msg.roomCode !== roomCode) return;
    if (msg.type === 'stateUpdate') {
      gameState = msg.data;
      onStateChange();
    }
  };
}

// â”€â”€ UTIL â”€â”€
function uid() { return Math.random().toString(36).slice(2,10); }
function showScreen(id) {
  document.querySelectorAll('.screen').forEach(s=>s.classList.remove('active'));
  document.getElementById(id).classList.add('active');
}
function toast(msg, duration=2500) {
  const el = document.createElement('div');
  el.className = 'toast-msg';
  el.textContent = msg;
  document.getElementById('toast').appendChild(el);
  setTimeout(()=>el.remove(), duration+300);
}
function lerp(a,b,t){return a+(b-a)*t;}

// â”€â”€ BLOB SVG RENDERER â”€â”€
function drawBlobSVG(color, size=40, hat='') {
  const s = size;
  return `<svg width="${s}" height="${s*1.2}" viewBox="0 0 40 48" xmlns="http://www.w3.org/2000/svg">
    <ellipse cx="20" cy="26" rx="17" ry="20" fill="${color}" />
    <ellipse cx="20" cy="26" rx="17" ry="20" fill="rgba(255,255,255,0.12)" />
    <circle cx="13" cy="20" r="5" fill="white"/>
    <circle cx="27" cy="20" r="5" fill="white"/>
    <circle cx="14" cy="21" r="2.5" fill="#1a0a2e"/>
    <circle cx="28" cy="21" r="2.5" fill="#1a0a2e"/>
    <circle cx="15" cy="20" r="1" fill="white"/>
    <circle cx="29" cy="20" r="1" fill="white"/>
    ${hat==='crown'?`<polygon points="8,14 14,4 20,10 26,4 32,14" fill="#FFE135" stroke="#cc9900" stroke-width="1"/>`:
      hat==='star'?`<text x="12" y="10" font-size="12">â­</text>`:''}
  </svg>`;
}

// Canvas-based blob drawing
function drawBlobOnCanvas(ctx, x, y, color, size, name, isDead, isImpostor, emoji='') {
  const r = size;
  // Shadow
  ctx.save();
  ctx.shadowColor = isDead ? 'rgba(150,0,0,0.5)' : color + '88';
  ctx.shadowBlur = 20;
  // Body
  ctx.beginPath();
  ctx.ellipse(x, y+4, r, r*1.1, 0, 0, Math.PI*2);
  ctx.fillStyle = isDead ? '#333' : color;
  ctx.fill();
  ctx.shadowBlur = 0;
  // Highlight
  ctx.beginPath();
  ctx.ellipse(x-r*0.2, y-r*0.2, r*0.5, r*0.35, -0.5, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.25)';
  ctx.fill();
  // Eyes
  if (!isDead) {
    ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.arc(x-r*0.3, y-r*0.1, r*0.28, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.3, y-r*0.1, r*0.28, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#1a0a2e';
    ctx.beginPath(); ctx.arc(x-r*0.25, y-r*0.08, r*0.14, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.35, y-r*0.08, r*0.14, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = 'white';
    ctx.beginPath(); ctx.arc(x-r*0.2, y-r*0.12, r*0.07, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+r*0.4, y-r*0.12, r*0.07, 0, Math.PI*2); ctx.fill();
  } else {
    // X eyes
    ctx.strokeStyle='#666'; ctx.lineWidth=2;
    [[x-r*0.3,y-r*0.1],[x+r*0.3,y-r*0.1]].forEach(([ex,ey])=>{
      ctx.beginPath(); ctx.moveTo(ex-5,ey-5); ctx.lineTo(ex+5,ey+5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ex+5,ey-5); ctx.lineTo(ex-5,ey+5); ctx.stroke();
    });
  }
  // Impostor glow
  if (isImpostor && myId && gameState && gameState.players[myId]?.isImpostor) {
    ctx.strokeStyle = '#ff4444';
    ctx.lineWidth = 3;
    ctx.setLineDash([4,4]);
    ctx.beginPath(); ctx.ellipse(x, y+4, r+3, r*1.1+3, 0, 0, Math.PI*2); ctx.stroke();
    ctx.setLineDash([]);
  }
  ctx.restore();
  // Name
  ctx.font = `bold ${Math.max(10,r*0.55)}px Nunito`;
  ctx.textAlign = 'center';
  ctx.fillStyle = isDead ? '#555' : 'white';
  ctx.strokeStyle = '#0005';
  ctx.lineWidth = 3;
  ctx.strokeText(name.substring(0,8), x, y+r*1.5+14);
  ctx.fillText(name.substring(0,8), x, y+r*1.5+14);
  if (emoji) {
    ctx.font = `${r}px serif`;
    ctx.fillText(emoji, x, y-r-4);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TITLE SCREEN
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initTitle() {
  const preview = document.getElementById('previewBlobs');
  preview.innerHTML = BLOB_COLORS.map((c,i) =>
    `<div style="width:48px;height:58px;animation:slotPop 0.4s ease ${i*0.05}s both">
      ${drawBlobSVG(c,48)}
    </div>`
  ).join('');
}

function setupColorPicker() {
  const pick = document.getElementById('colorPick');
  pick.innerHTML = BLOB_COLORS.map((c,i) =>
    `<div class="color-swatch ${i===myColor?'chosen':''}" style="background:${c}" onclick="chooseColor(${i})" title="${COLOR_NAMES[i]}"></div>`
  ).join('');
}

function chooseColor(i) {
  myColor = i;
  document.querySelectorAll('.color-swatch').forEach((el,j)=>el.classList.toggle('chosen',j===i));
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  ROOM MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showCreateRoom() {
  isHost = true;
  roomCode = genRoomCode();
  document.getElementById('join-title').textContent = 'ğŸ‰ Host a Game!';
  document.getElementById('join-code-section').style.display = 'none';
  document.getElementById('joinBtn').textContent = 'Create Room ğŸ‰';
  setupColorPicker();
  showScreen('screen-join');
}

function showJoinRoom() {
  isHost = false;
  document.getElementById('join-title').textContent = 'ğŸš€ Join a Game!';
  document.getElementById('join-code-section').style.display = 'block';
  document.getElementById('joinBtn').textContent = 'Join Room ğŸš€';
  setupColorPicker();
  showScreen('screen-join');
}

function enterLobby() {
  const name = document.getElementById('nameInput').value.trim();
  if (!name) { toast('Enter your name! ğŸ‘‹'); return; }
  myName = name;
  myId = uid();

  if (!isHost) {
    const code = document.getElementById('codeInput').value.trim().toUpperCase();
    if (code.length < 4) { toast('Enter the room code!'); return; }
    roomCode = code;
    const room = getRoom();
    if (!room) { toast('Room not found! Check the code ğŸ¤”'); return; }
    if (room.phase !== 'lobby') { toast('Game already started!'); return; }
    if (Object.keys(room.players).length >= 12) { toast('Room is full! (12 max)'); return; }
  }

  setupChannel();

  if (isHost) {
    // Create new room
    const room = {
      code: roomCode,
      phase: 'lobby',
      hostId: myId,
      players: {},
      tasks: {},
      votes: {},
      globalTasksDone: 0,
      totalTasks: 0,
      meeting: null,
      sabotage: null,
      killLog: [],
      winState: null,
    };
    room.players[myId] = makePlayer(myId, myName, myColor, true);
    setRoom(room);
  } else {
    const room = getRoom();
    room.players[myId] = makePlayer(myId, myName, myColor, false);
    setRoom(room);
  }

  gameState = getRoom();
  localPlayer = gameState.players[myId];
  updateLobbyUI();
  showScreen('screen-lobby');
  startLobbyPolling();
}

function makePlayer(id, name, colorIdx, host) {
  return {
    id, name, colorIdx,
    color: BLOB_COLORS[colorIdx],
    isHost: host,
    isImpostor: false,
    alive: true,
    x: MAP_W/2 + (Math.random()-0.5)*300,
    y: MAP_H/2 + (Math.random()-0.5)*200,
    vx: 0, vy: 0,
    tasksTotal: TASKS_PER_PLAYER,
    tasksDone: 0,
    joinTime: Date.now(),
  };
}

function leaveLobby() {
  if (gameState && gameState.players[myId]) {
    delete gameState.players[myId];
    if (isHost) {
      const ids = Object.keys(gameState.players);
      if (ids.length > 0) {
        gameState.hostId = ids[0];
        gameState.players[ids[0]].isHost = true;
      } else {
        sessionStorage.removeItem('blobparty_' + roomCode);
      }
    }
    setRoom(gameState);
  }
  if (lobbyPoller) clearInterval(lobbyPoller);
  if (channel) channel.close();
  showScreen('screen-title');
}

let lobbyPoller = null;
function startLobbyPolling() {
  if (lobbyPoller) clearInterval(lobbyPoller);
  lobbyPoller = setInterval(() => {
    gameState = getRoom();
    if (!gameState) return;
    if (gameState.phase === 'game') {
      clearInterval(lobbyPoller);
      initGame();
      return;
    }
    updateLobbyUI();
  }, 500);
}

function updateLobbyUI() {
  if (!gameState) return;
  document.getElementById('lobby-code-display').textContent = roomCode;
  const players = Object.values(gameState.players);
  const grid = document.getElementById('playersGrid');
  grid.innerHTML = '';

  for (let i=0;i<12;i++) {
    const p = players[i];
    const slot = document.createElement('div');
    slot.className = 'player-slot' + (p?' filled':'');
    if (p) {
      slot.innerHTML = `
        <div style="width:48px;height:58px;">${drawBlobSVG(p.color,48,p.isHost?'crown':'')}</div>
        <div class="slot-name" style="color:${p.color}">${p.name}</div>
        <div class="slot-badge">${p.isHost?'ğŸ‘‘ HOST':''}</div>
      `;
    } else {
      slot.innerHTML = `<div style="font-size:28px;opacity:0.2;">ğŸ‘¤</div><div style="font-size:10px;color:#403060;margin-top:4px;">Empty</div>`;
    }
    grid.appendChild(slot);
  }

  const count = players.length;
  document.getElementById('lobbyStatus').textContent = `${count}/12 players joined`;

  const amHost = gameState.hostId === myId;
  document.getElementById('startBtn').style.display = amHost && count >= 2 ? 'block' : 'none';
  document.getElementById('waitMsg').style.display = amHost ? 'none' : 'block';
  document.getElementById('waitMsg').textContent = count < 2 ? 'Need at least 2 players...' : 'Waiting for host to start...';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME START
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function startGame() {
  gameState = getRoom();
  const players = Object.values(gameState.players);
  const n = players.length;

  // Assign impostors
  const impCount = IMPOSTOR_COUNT[Math.min(n, 12)] || 2;
  const shuffled = [...players].sort(()=>Math.random()-0.5);
  shuffled.forEach((p,i)=>{
    gameState.players[p.id].isImpostor = i < impCount;
  });

  // Assign tasks
  const totalTasks = n * TASKS_PER_PLAYER;
  gameState.totalTasks = totalTasks;
  gameState.globalTasksDone = 0;

  // Spawn positions (room layout)
  const spawnPoints = generateSpawnPoints(n);
  players.forEach((p,i)=>{
    gameState.players[p.id].x = spawnPoints[i][0];
    gameState.players[p.id].y = spawnPoints[i][1];
    gameState.players[p.id].alive = true;
    gameState.players[p.id].tasksDone = 0;
  });

  gameState.phase = 'game';
  gameState.startTime = Date.now();
  gameState.killLog = [];
  gameState.votes = {};
  gameState.meeting = null;
  gameState.winState = null;

  setRoom(gameState);
  toast('Game starting! ğŸš€');
  initGame();
}

function generateSpawnPoints(n) {
  const cx = MAP_W/2, cy = MAP_H/2;
  const pts = [];
  for (let i=0;i<n;i++) {
    const angle = (i/n) * Math.PI * 2;
    pts.push([cx + Math.cos(angle)*150, cy + Math.sin(angle)*150]);
  }
  return pts;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME INITIALIZATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function initGame() {
  showScreen('screen-game');
  canvas = document.getElementById('game-canvas');
  ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth - 220;
  canvas.height = window.innerHeight;

  gameState = getRoom();
  localPlayer = gameState.players[myId];
  isImpostor = localPlayer?.isImpostor || false;
  tasksDone = [];
  myVote = null;
  killCooldownLeft = isImpostor ? KILL_COOLDOWN : 0;

  if (isImpostor) {
    toast('ğŸ˜ˆ You are the IMPOSTOR! Act natural...', 4000);
    document.getElementById('killBtn').style.display = 'block';
  } else {
    toast('ğŸ”µ You are a CREW member! Do your tasks!', 3000);
    document.getElementById('killBtn').style.display = 'none';
  }

  // Keyboard input
  document.onkeydown = e => { keys[e.code]=true; };
  document.onkeyup = e => { keys[e.code]=false; };

  // Game polling
  if (gameLoop) clearInterval(gameLoop);
  gameLoop = setInterval(pollGameState, 100);

  // Start render loop
  if (animFrame) cancelAnimationFrame(animFrame);
  renderLoop();
}

function pollGameState() {
  const newState = getRoom();
  if (!newState) return;

  // Check meeting
  if (newState.meeting && (!gameState.meeting || newState.meeting.id !== gameState.meeting?.id)) {
    gameState = newState;
    openMeeting(newState.meeting);
    return;
  }

  // Check win
  if (newState.winState && !gameState.winState) {
    gameState = newState;
    showResult(newState.winState);
    return;
  }

  gameState = newState;
  updateGameUI();

  // Check wins
  if (gameState.hostId === myId) {
    checkWinConditions();
  }
}

function checkWinConditions() {
  if (gameState.winState) return;
  const players = Object.values(gameState.players);
  const alive = players.filter(p=>p.alive);
  const impostors = alive.filter(p=>p.isImpostor);
  const crew = alive.filter(p=>!p.isImpostor);

  // Crew tasks win
  if (gameState.globalTasksDone >= gameState.totalTasks && gameState.totalTasks > 0) {
    endGame('crew', 'tasks');
    return;
  }
  // Impostors equal or outnumber crew
  if (impostors.length >= crew.length && impostors.length > 0) {
    endGame('impostors', 'overwhelm');
    return;
  }
  // All impostors ejected/killed
  if (impostors.length === 0) {
    endGame('crew', 'ejected');
    return;
  }
}

function endGame(winner, reason) {
  gameState.winState = { winner, reason, timestamp: Date.now() };
  setRoom(gameState);
  showResult(gameState.winState);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RENDER LOOP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const MAP_ROOMS = [
  { x:100,  y:100,  w:400, h:280, name:'ğŸš€ Launch Bay', color:'#1a2040' },
  { x:600,  y:80,   w:350, h:250, name:'âš¡ Power Plant', color:'#1a1520' },
  { x:1050, y:100,  w:380, h:270, name:'ğŸ”¬ Lab', color:'#0a1a20' },
  { x:100,  y:480,  w:300, h:260, name:'ğŸ• Cafeteria', color:'#1a1200' },
  { x:500,  y:500,  w:500, h:300, name:'ğŸŒ¿ Garden', color:'#0a1a08' },
  { x:1100, y:480,  w:380, h:280, name:'ğŸ›  Engine Room', color:'#201010' },
  { x:250,  y:880,  w:400, h:250, name:'ğŸ“¡ Comms', color:'#0a0a20' },
  { x:800,  y:900,  w:600, h:250, name:'ğŸ’¨ Vents', color:'#151520' },
  // Corridors
  { x:400,  y:300,  w:200, h:200, name:'', color:'#111118' },
  { x:900,  y:300,  w:200, h:200, name:'', color:'#111118' },
  { x:380,  y:650,  w:150, h:250, name:'', color:'#111118' },
  { x:980,  y:700,  w:150, h:200, name:'', color:'#111118' },
];

const TASK_LOCATIONS = [
  {x:200,y:200},{x:700,y:160},{x:1200,y:200},
  {x:200,y:600},{x:700,y:640},{x:1250,y:600},
  {x:400,y:950},{x:1000,y:970},{x:600,y:350},
  {x:1000,y:350},{x:300,y:780},{x:1350,y:750},
];
let completedTaskLocations = [];
let activeTaskIndex = -1;

function renderLoop() {
  if (!canvas || !ctx) return;
  animFrame = requestAnimationFrame(renderLoop);

  // Move local player
  movePlayer();

  const W = canvas.width, H = canvas.height;
  ctx.clearRect(0,0,W,H);

  // Camera follows local player
  if (localPlayer && gameState?.players[myId]) {
    const p = gameState.players[myId];
    cameraX = p.x - W/2;
    cameraY = p.y - H/2;
  }
  cameraX = Math.max(0, Math.min(MAP_W - W, cameraX));
  cameraY = Math.max(0, Math.min(MAP_H - H, cameraY));

  ctx.save();
  ctx.translate(-cameraX, -cameraY);

  // Draw map
  drawMap();

  // Draw task locations
  drawTaskMarkers();

  // Draw players
  if (gameState?.players) {
    const players = Object.values(gameState.players).sort((a,b)=>a.y-b.y);
    players.forEach(p => {
      if (!p) return;
      const isMe = p.id === myId;
      const isThisImpostor = p.isImpostor && (isImpostor || !p.alive);
      drawBlobOnCanvas(ctx, p.x, p.y, p.color, isMe?20:16, p.name, !p.alive, isThisImpostor, isMe?'':'');
      if (isMe) {
        // Arrow indicator
        ctx.beginPath();
        ctx.arc(p.x, p.y, 26, 0, Math.PI*2);
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([4,4]);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    });
  }

  // Kill range indicator for impostors
  if (isImpostor && gameState?.players[myId]?.alive) {
    const me = gameState.players[myId];
    ctx.beginPath();
    ctx.arc(me.x, me.y, 120, 0, Math.PI*2);
    ctx.strokeStyle = 'rgba(255,50,50,0.2)';
    ctx.lineWidth = 2;
    ctx.setLineDash([6,6]);
    ctx.stroke();
    ctx.setLineDash([]);
  }

  ctx.restore();

  // HUD
  drawHUD(W, H);
  updateKillCooldown();
}

function drawMap() {
  // Background void
  ctx.fillStyle = '#0a0612';
  ctx.fillRect(0, 0, MAP_W, MAP_H);

  // Stars in bg
  ctx.fillStyle = 'rgba(255,255,255,0.03)';
  for (let i=0;i<200;i++) {
    const sx = (i*137.508)%MAP_W;
    const sy = (i*197.342)%MAP_H;
    ctx.fillRect(sx,sy,1,1);
  }

  // Rooms
  MAP_ROOMS.forEach(room => {
    // Room fill
    ctx.fillStyle = room.color;
    ctx.beginPath();
    ctx.roundRect(room.x, room.y, room.w, room.h, 16);
    ctx.fill();
    // Room border
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Room name
    if (room.name) {
      ctx.font = 'bold 14px Nunito';
      ctx.fillStyle = 'rgba(255,255,255,0.4)';
      ctx.textAlign = 'center';
      ctx.fillText(room.name, room.x+room.w/2, room.y+22);
    }
  });
}

function drawTaskMarkers() {
  TASK_LOCATIONS.forEach((loc, i) => {
    const done = tasksDone.includes(i) || completedTaskLocations.includes(i);
    const isActive = i === activeTaskIndex;

    // Glow
    const grd = ctx.createRadialGradient(loc.x, loc.y, 0, loc.x, loc.y, 40);
    grd.addColorStop(0, done ? 'rgba(77,255,145,0.2)' : isActive ? 'rgba(255,225,53,0.3)' : 'rgba(0,229,255,0.15)');
    grd.addColorStop(1, 'transparent');
    ctx.beginPath(); ctx.arc(loc.x, loc.y, 40, 0, Math.PI*2); ctx.fillStyle=grd; ctx.fill();

    ctx.beginPath();
    ctx.arc(loc.x, loc.y, 14, 0, Math.PI*2);
    ctx.fillStyle = done ? '#4DFF91' : isActive ? '#FFE135' : '#00E5FF';
    ctx.fill();
    ctx.font = '14px serif';
    ctx.textAlign = 'center';
    ctx.fillText(done ? 'âœ“' : '!', loc.x, loc.y+5);
  });
}

function drawHUD(W, H) {
  // Kill cooldown bar
  if (isImpostor && killCooldownLeft > 0) {
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.beginPath(); ctx.roundRect(W/2-80, H-40, 160, 20, 10); ctx.fill();
    ctx.fillStyle = '#ff5555';
    ctx.beginPath(); ctx.roundRect(W/2-78, H-38, 156*(1-killCooldownLeft/KILL_COOLDOWN), 16, 8); ctx.fill();
    ctx.font = '11px Nunito';
    ctx.fillStyle = 'white'; ctx.textAlign='center';
    ctx.fillText(`KILL: ${Math.ceil(killCooldownLeft)}s`, W/2, H-26);
  }

  // Task interaction hint
  if (activeTaskIndex >= 0) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.beginPath(); ctx.roundRect(W/2-90, 60, 180, 32, 16); ctx.fill();
    ctx.font = 'bold 14px Nunito';
    ctx.fillStyle = '#FFE135'; ctx.textAlign='center';
    ctx.fillText('Press E to do task!', W/2, 82);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PLAYER MOVEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let moveThrottle = 0;
function movePlayer() {
  if (!gameState?.players?.[myId]) return;
  const p = gameState.players[myId];
  if (!p.alive) return;

  let moved = false;
  if (keys['ArrowLeft']||keys['KeyA']) { p.x -= MOVE_SPEED; moved=true; }
  if (keys['ArrowRight']||keys['KeyD']) { p.x += MOVE_SPEED; moved=true; }
  if (keys['ArrowUp']||keys['KeyW']) { p.y -= MOVE_SPEED; moved=true; }
  if (keys['ArrowDown']||keys['KeyS']) { p.y += MOVE_SPEED; moved=true; }
  if (keys['KeyE']) checkTaskInteraction();

  p.x = Math.max(80, Math.min(MAP_W-80, p.x));
  p.y = Math.max(80, Math.min(MAP_H-80, p.y));

  // Check if near task
  activeTaskIndex = -1;
  if (!isImpostor) {
    TASK_LOCATIONS.forEach((loc,i)=>{
      if (tasksDone.includes(i)) return;
      const dist = Math.hypot(p.x-loc.x, p.y-loc.y);
      if (dist < 60) activeTaskIndex = i;
    });
  }

  // Sync position
  moveThrottle++;
  if (moved || moveThrottle % 5 === 0) {
    gameState.players[myId] = p;
    setRoom(gameState);
  }
}

function checkTaskInteraction() {
  if (activeTaskIndex >= 0 && !document.getElementById('task-popup').classList.contains('show')) {
    openTask(activeTaskIndex);
    keys['KeyE'] = false;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  GAME UI UPDATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateGameUI() {
  if (!gameState?.players) return;
  const players = Object.values(gameState.players);
  const list = document.getElementById('playerList');
  list.innerHTML = '';
  players.forEach(p => {
    const el = document.createElement('div');
    el.className = 'player-row' + (!p.alive?' is-out':'') + (p.isImpostor && isImpostor?' is-impostor':'');
    const taskPct = p.tasksTotal>0 ? (p.tasksDone/p.tasksTotal)*100 : 0;
    el.innerHTML = `
      <div class="mini-blob" style="background:${p.color};box-shadow:0 0 8px ${p.color}44"></div>
      <div style="flex:1;min-width:0;">
        <div style="white-space:nowrap;overflow:hidden;text-overflow:ellipsis;">${p.name}${p.id===myId?' (you)':''}${!p.alive?' ğŸ’€':''}</div>
        ${!isImpostor?`<div class="task-bar-wrap"><div class="task-bar-fill" style="width:${taskPct}%"></div></div>`:''}
      </div>
    `;
    list.appendChild(el);
  });

  // Global task bar
  const pct = gameState.totalTasks>0 ? Math.round((gameState.globalTasksDone/gameState.totalTasks)*100) : 0;
  document.getElementById('globalTaskBar').style.width = pct + '%';
  document.getElementById('taskProgress').textContent = `${gameState.globalTasksDone}/${gameState.totalTasks} complete (${pct}%)`;

  const banner = document.getElementById('phaseBanner');
  banner.textContent = isImpostor ? 'ğŸ˜ˆ You are the IMPOSTOR!' : 'ğŸ”µ Complete your tasks!';

  // Kill button state
  const killBtn = document.getElementById('killBtn');
  if (isImpostor) {
    killBtn.style.display='block';
    killBtn.disabled = killCooldownLeft>0;
    killBtn.style.opacity = killCooldownLeft>0 ? '0.4':'1';
  }
}

function updateKillCooldown() {
  if (killCooldownLeft > 0) killCooldownLeft -= 1/60;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TASKS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
let taskDef = null;
let taskSuccess = false;

function openTask(locIndex) {
  if (isImpostor) {
    toast('ğŸ˜ˆ Impostors fake tasks...');
    // Impostors just wait to look busy
    setTimeout(()=>{ toast('(You pretended to work ğŸ˜)'); }, 1500);
    return;
  }
  const loc = locIndex !== undefined ? locIndex : activeTaskIndex;
  if (loc < 0) { toast('Get closer to a task first!'); return; }

  const tIdx = loc % TASK_DEFS.length;
  taskDef = TASK_DEFS[tIdx];
  currentTask = { locIndex: loc, def: taskDef };

  document.getElementById('taskTitle').textContent = taskDef.emoji + ' ' + taskDef.name;
  document.getElementById('taskDesc').textContent = taskDef.desc;
  document.getElementById('task-popup').classList.add('show');
  buildTaskGame(taskDef.id);
}

function closeTask() {
  document.getElementById('task-popup').classList.remove('show');
  taskDef = null; currentTask = null;
}

function completeTask(locIndex) {
  if (tasksDone.includes(locIndex)) return;
  tasksDone.push(locIndex);
  completedTaskLocations.push(locIndex);

  gameState = getRoom();
  gameState.players[myId].tasksDone++;
  gameState.globalTasksDone++;
  setRoom(gameState);

  toast('âœ… Task complete! +1');
  closeTask();
  confettiBurst(10);
}

function buildTaskGame(type) {
  const area = document.getElementById('taskGameArea');
  area.innerHTML = '';

  if (type === 'color') buildColorTask(area);
  else if (type === 'simon') buildSimonTask(area);
  else if (type === 'whack') buildWhackTask(area);
  else if (type === 'wire') buildWireTask(area);
}

// â”€â”€ COLOR MATCH TASK â”€â”€
function buildColorTask(area) {
  const targetIdx = Math.floor(Math.random()*6);
  const target = BLOB_COLORS[targetIdx];
  area.innerHTML = `
    <div style="text-align:center;margin-bottom:12px;">
      <div style="font-size:14px;color:#8080aa;margin-bottom:8px;">Tap this color:</div>
      <div style="width:60px;height:60px;border-radius:50%;background:${target};margin:0 auto;border:3px solid white;box-shadow:0 0 20px ${target}"></div>
    </div>
    <div class="color-match-grid" id="cmGrid"></div>
  `;
  const grid = area.querySelector('#cmGrid');
  const options = [...BLOB_COLORS].sort(()=>Math.random()-0.5).slice(0,8);
  if (!options.includes(target)) options[0]=target;
  options.sort(()=>Math.random()-0.5);
  options.forEach(c=>{
    const cell = document.createElement('div');
    cell.className='cm-cell';
    cell.style.background=c;
    cell.onclick = ()=>{
      if (c===target) { completeTask(currentTask.locIndex); }
      else { toast('âŒ Wrong color!'); cell.style.border='3px solid #ff4444'; setTimeout(()=>cell.style.border='3px solid transparent',500); }
    };
    grid.appendChild(cell);
  });
}

// â”€â”€ SIMON TASK â”€â”€
let simonSeq=[], simonPlayer=[], simonStep=0, simonPlaying=false;
const SIMON_COLORS=['#ff4d4d','#4dff91','#ffe135','#4d79ff'];
function buildSimonTask(area) {
  simonSeq=[]; simonPlayer=[]; simonStep=0; simonPlaying=false;
  const n=Math.floor(Math.random()*2)+3;
  for(let i=0;i<n;i++) simonSeq.push(Math.floor(Math.random()*4));

  area.innerHTML=`
    <div style="text-align:center;font-size:12px;color:#8080aa;margin-bottom:8px;">Watch, then repeat the pattern!</div>
    <div class="simon-grid">
      ${SIMON_COLORS.map((c,i)=>`<button class="simon-btn" id="sb${i}" style="background:${c};color:#1a0a2e;" onclick="simonPress(${i})">
        ${['ğŸ”´','ğŸŸ¢','ğŸŸ¡','ğŸ”µ'][i]}
      </button>`).join('')}
    </div>
    <div id="simonMsg" style="text-align:center;margin-top:10px;font-size:14px;color:#8080aa;">Get ready...</div>
  `;
  setTimeout(()=>playSimonSeq(), 800);
}
function playSimonSeq() {
  simonPlaying=true;
  document.getElementById('simonMsg').textContent='Watch carefully!';
  let i=0;
  const interval=setInterval(()=>{
    if(i>0){ const prev=document.getElementById('sb'+simonSeq[i-1]); if(prev){prev.classList.remove('lit');}}
    if(i>=simonSeq.length){ clearInterval(interval); simonPlaying=false; document.getElementById('simonMsg').textContent='Your turn! Repeat!'; return; }
    const btn=document.getElementById('sb'+simonSeq[i]); if(btn){btn.classList.add('lit');}
    i++;
  },600);
}
function simonPress(idx) {
  if(simonPlaying) return;
  const btn=document.getElementById('sb'+idx);
  if(btn){btn.classList.add('lit'); setTimeout(()=>btn.classList.remove('lit'),200);}
  simonPlayer.push(idx);
  const pos=simonPlayer.length-1;
  if(simonPlayer[pos]!==simonSeq[pos]){ toast('âŒ Wrong! Try again!'); simonPlayer=[]; return; }
  if(simonPlayer.length===simonSeq.length){ completeTask(currentTask.locIndex); }
}

// â”€â”€ WHACK TASK â”€â”€
let whackScore=0, whackTarget=3;
function buildWhackTask(area) {
  whackScore=0; whackTarget=5;
  area.innerHTML=`
    <div style="text-align:center;font-size:13px;color:#8080aa;margin-bottom:8px;">Whack the ğŸ«§ blobs! (<span id="whackScore">0</span>/${whackTarget})</div>
    <div class="whack-grid" id="whackGrid"></div>
  `;
  const grid=area.querySelector('#whackGrid');
  for(let i=0;i<9;i++){
    const h=document.createElement('div'); h.className='whack-hole'; h.id='wh'+i;
    grid.appendChild(h);
  }
  startWhacking();
}
let whackInterval=null;
function startWhacking(){
  if(whackInterval) clearInterval(whackInterval);
  whackInterval=setInterval(()=>{
    if(!currentTask){clearInterval(whackInterval);return;}
    document.querySelectorAll('.whack-hole').forEach(h=>h.innerHTML='');
    const active=Math.floor(Math.random()*9);
    const h=document.getElementById('wh'+active);
    if(!h){clearInterval(whackInterval);return;}
    h.innerHTML='ğŸ«§';
    h.onclick=()=>{
      h.innerHTML='ğŸ’¥'; whackScore++;
      document.getElementById('whackScore').textContent=whackScore;
      if(whackScore>=whackTarget){clearInterval(whackInterval);completeTask(currentTask.locIndex);}
    };
  },800);
}

// â”€â”€ WIRE TASK â”€â”€
let wireSelected=null, wireConnections={};
const WIRE_COLORS=['#ff4d8d','#ffe135','#00e5ff','#4dff91'];
function buildWireTask(area) {
  wireSelected=null; wireConnections={};
  area.innerHTML=`
    <div style="font-size:12px;color:#8080aa;text-align:center;margin-bottom:10px;">Connect matching colored wires!</div>
    <div class="wire-area">
      <div class="wire-col" id="wireLeft"></div>
      <div style="flex:1;position:relative;height:180px;">
        <canvas id="wireCanvas" width="200" height="180"></canvas>
      </div>
      <div class="wire-col" id="wireRight"></div>
    </div>
    <div id="wireMsg" style="text-align:center;font-size:12px;color:#8080aa;margin-top:8px;">Tap left node, then matching right node</div>
  `;
  const leftOrder=[0,1,2,3].sort(()=>Math.random()-0.5);
  const rightOrder=[0,1,2,3].sort(()=>Math.random()-0.5);
  leftOrder.forEach((ci,i)=>{
    const n=document.createElement('div');
    n.className='wire-node'; n.style.background=WIRE_COLORS[ci];
    n.dataset.colorIdx=ci; n.dataset.side='left'; n.dataset.pos=i;
    n.textContent=''; n.id=`wl${ci}`;
    n.onclick=()=>wireClick('left',ci,n);
    area.querySelector('#wireLeft').appendChild(n);
  });
  rightOrder.forEach((ci,i)=>{
    const n=document.createElement('div');
    n.className='wire-node'; n.style.background=WIRE_COLORS[ci];
    n.dataset.colorIdx=ci; n.dataset.side='right'; n.dataset.pos=i;
    n.textContent=''; n.id=`wr${ci}`;
    n.onclick=()=>wireClick('right',ci,n);
    area.querySelector('#wireRight').appendChild(n);
  });
}
function wireClick(side,colorIdx,el){
  if(side==='left'){
    if(wireConnections[colorIdx]){return;}
    document.querySelectorAll('.wire-node.selected').forEach(n=>n.classList.remove('selected'));
    wireSelected=colorIdx; el.classList.add('selected');
  } else {
    if(wireSelected===null){toast('Pick a left node first!');return;}
    if(wireConnections[wireSelected]!==undefined){return;}
    if(wireSelected===colorIdx){
      wireConnections[colorIdx]=true;
      el.classList.add('selected');
      document.getElementById('wl'+colorIdx)?.classList.add('selected');
      drawWires();
      wireSelected=null;
      if(Object.keys(wireConnections).length===4){completeTask(currentTask.locIndex);}
    } else {
      toast('âŒ Wrong color!'); wireSelected=null;
      document.querySelectorAll('.wire-node.selected').forEach(n=>n.classList.remove('selected'));
    }
  }
}
function drawWires(){
  const wc=document.getElementById('wireCanvas');
  if(!wc)return;
  const wctx=wc.getContext('2d');
  wctx.clearRect(0,0,wc.width,wc.height);
  Object.keys(wireConnections).forEach(ci=>{
    const lNode=document.getElementById('wl'+ci);
    const rNode=document.getElementById('wr'+ci);
    if(!lNode||!rNode)return;
    wctx.beginPath();
    wctx.moveTo(0,90+parseInt(ci)*20-30);
    wctx.bezierCurveTo(60,80+parseInt(ci)*15,140,80+parseInt(ci)*15,200,90+parseInt(ci)*20-30);
    wctx.strokeStyle=WIRE_COLORS[parseInt(ci)];
    wctx.lineWidth=4; wctx.lineCap='round';
    wctx.stroke();
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  KILL
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function performKill() {
  if (!isImpostor || killCooldownLeft>0) return;
  gameState = getRoom();
  const me = gameState.players[myId];
  if (!me?.alive) return;

  let victim = null, closestDist = Infinity;
  Object.values(gameState.players).forEach(p=>{
    if (p.id===myId || !p.alive || p.isImpostor) return;
    const dist = Math.hypot(p.x-me.x, p.y-me.y);
    if (dist < 120 && dist < closestDist) { closestDist=dist; victim=p; }
  });

  if (!victim) { toast('No crew nearby! Get closer ğŸ˜ˆ'); return; }

  gameState.players[victim.id].alive = false;
  gameState.killLog.push({ killerId:myId, victimId:victim.id, time:Date.now() });
  setRoom(gameState);

  killCooldownLeft = KILL_COOLDOWN;
  toast(`ğŸ’€ You got ${victim.name}! ğŸ˜ˆ`);

  const flash = document.createElement('div');
  flash.className='kill-flash';
  document.body.appendChild(flash);
  setTimeout(()=>flash.remove(),700);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  MEETINGS & VOTING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function callMeeting() {
  gameState = getRoom();
  if (!gameState.players[myId]?.alive) { toast("You're a ghost! ğŸ‘»"); return; }
  if (gameState.meeting) { toast('Meeting already in progress!'); return; }

  const meetingId = uid();
  gameState.meeting = {
    id: meetingId,
    callerId: myId,
    callerName: gameState.players[myId].name,
    votes: {},
    startTime: Date.now(),
    resolved: false,
  };
  setRoom(gameState);
  toast('ğŸš¨ Emergency Meeting called!');
}

function openMeeting(meeting) {
  if (!meeting || meeting.resolved) return;
  clearInterval(gameLoop);
  document.getElementById('vote-popup').classList.add('show');
  document.getElementById('voteSubtitle').textContent =
    `${meeting.callerName} called a meeting! Vote out the impostor!`;

  myVote = null;
  voteTimeLeft = VOTE_TIME;
  buildVoteGrid();

  if (voteTimer) clearInterval(voteTimer);
  voteTimer = setInterval(()=>{
    voteTimeLeft--;
    document.getElementById('voteTimerDisplay').textContent = voteTimeLeft;
    if (voteTimeLeft<=0) { clearInterval(voteTimer); resolveVote(); }

    // Refresh vote display
    gameState = getRoom();
    refreshVoteCounts();
  },1000);
}

function buildVoteGrid() {
  gameState = getRoom();
  const grid = document.getElementById('voteGrid');
  grid.innerHTML = '';
  Object.values(gameState.players).filter(p=>p.alive).forEach(p=>{
    const card = document.createElement('div');
    card.className = 'vote-card' + (p.id===myId?' vote-card-me':'');
    card.id='vc_'+p.id;
    card.innerHTML=`
      <div style="width:54px;height:66px;margin:0 auto;">${drawBlobSVG(p.color,54)}</div>
      <div class="vname">${p.name}${p.id===myId?' (you)':''}</div>
      <div class="vote-count-badge" id="vb_${p.id}"></div>
    `;
    if (p.id!==myId) card.onclick=()=>castVote(p.id);
    grid.appendChild(card);
  });

  // Skip
  const skip = document.createElement('div');
  skip.className='vote-card skip-card';
  skip.innerHTML=`<div style="font-size:36px;">â­ï¸</div><div class="vname">Skip Vote</div>`;
  skip.onclick=()=>castVote('skip');
  grid.appendChild(skip);
}

function castVote(targetId) {
  if (myVote) { toast('Already voted!'); return; }
  myVote = targetId;

  document.querySelectorAll('.vote-card').forEach(c=>c.classList.remove('voted-for'));
  const vc = document.getElementById('vc_'+targetId);
  if (vc) vc.classList.add('voted-for');

  gameState = getRoom();
  if (!gameState.meeting) return;
  gameState.meeting.votes[myId] = targetId;
  setRoom(gameState);
  toast('âœ… Vote cast!');

  // Check if everyone voted
  const alivePlayers = Object.values(gameState.players).filter(p=>p.alive);
  const voteCount = Object.keys(gameState.meeting.votes).length;
  if (voteCount >= alivePlayers.length) { clearInterval(voteTimer); resolveVote(); }
}

function refreshVoteCounts() {
  if (!gameState?.meeting?.votes) return;
  const tally = {};
  Object.values(gameState.meeting.votes).forEach(v=>{ tally[v]=(tally[v]||0)+1; });
  Object.keys(tally).forEach(id=>{
    const el=document.getElementById('vb_'+id);
    if(el){ el.textContent=tally[id]+'ğŸ—³ï¸'; el.classList.add('show'); }
  });
}

function resolveVote() {
  gameState = getRoom();
  if (!gameState.meeting || gameState.meeting.resolved) return;

  const votes = gameState.meeting.votes;
  const tally = {};
  Object.values(votes).forEach(v=>{ tally[v]=(tally[v]||0)+1; });

  let maxVotes=0, ejected=null, tie=false;
  Object.entries(tally).forEach(([id,count])=>{
    if(count>maxVotes){maxVotes=count;ejected=id;tie=false;}
    else if(count===maxVotes){tie=true;}
  });

  if (tie||ejected==='skip'||!ejected) {
    toast('ğŸ¤· No one was ejected! (Tie or skip)');
  } else {
    const target = gameState.players[ejected];
    if (target) {
      gameState.players[ejected].alive = false;
      const wasImp = target.isImpostor;
      toast(`ğŸš€ ${target.name} was ejected! ${wasImp?'They WERE the impostor! ğŸ‰':'They were innocent... ğŸ˜¬'}`, 4000);
    }
  }

  gameState.meeting.resolved = true;
  gameState.meeting = null;
  setRoom(gameState);

  setTimeout(()=>{
    document.getElementById('vote-popup').classList.remove('show');
    myVote = null;
    gameState = getRoom();
    gameLoop = setInterval(pollGameState, 100);
    checkWinConditions();
  }, 2000);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  RESULT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function showResult(winState) {
  clearInterval(gameLoop);
  cancelAnimationFrame(animFrame);
  if(voteTimer) clearInterval(voteTimer);
  document.getElementById('vote-popup').classList.remove('show');
  document.getElementById('task-popup').classList.remove('show');

  const crewWin = winState.winner==='crew';
  document.getElementById('resultTitle').textContent = crewWin ? 'ğŸ‰ CREW WINS!' : 'ğŸ˜ˆ IMPOSTORS WIN!';
  document.getElementById('resultTitle').className = 'result-title ' + (crewWin?'crewwin':'impwin');
  document.getElementById('resultReveal').textContent = crewWin
    ? (winState.reason==='tasks'?'All tasks completed! Great teamwork!':'The impostors were found out!')
    : 'The impostors took over! Better luck next time!';

  gameState = getRoom();
  const impostors = Object.values(gameState.players).filter(p=>p.isImpostor);
  document.getElementById('resultImpostors').innerHTML = impostors.map(p=>`
    <div class="result-blob-card">
      <div style="width:70px;height:85px;margin:0 auto;">${drawBlobSVG(p.color,70,'crown')}</div>
      <div class="rname" style="color:${p.color}">${p.name}</div>
      <div style="font-size:11px;color:#ff5577;margin-top:4px;">ğŸ˜ˆ Impostor</div>
    </div>
  `).join('');

  const players = Object.values(gameState.players);
  document.getElementById('resultStats').textContent =
    `${players.length} players Â· ${gameState.globalTasksDone}/${gameState.totalTasks} tasks completed`;

  showScreen('screen-result');
  confettiBurst(50);
}

function playAgain() {
  gameState = getRoom();
  if (!gameState) { showScreen('screen-title'); return; }
  gameState.phase = 'lobby';
  gameState.winState = null;
  gameState.meeting = null;
  gameState.votes = {};
  gameState.killLog = [];
  gameState.globalTasksDone = 0;
  Object.values(gameState.players).forEach(p=>{
    p.isImpostor=false; p.alive=true; p.tasksDone=0;
  });
  setRoom(gameState);
  tasksDone=[]; completedTaskLocations=[];
  updateLobbyUI();
  showScreen('screen-lobby');
  startLobbyPolling();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  STATE CHANGE (from broadcast)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function onStateChange() {
  const screen = document.querySelector('.screen.active')?.id;
  if (screen==='screen-lobby') updateLobbyUI();
  else if (screen==='screen-game') {
    updateGameUI();
    if (gameState.meeting && !document.getElementById('vote-popup').classList.contains('show')) {
      openMeeting(gameState.meeting);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFETTI
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function confettiBurst(n=20) {
  for (let i=0;i<n;i++) {
    setTimeout(()=>{
      const el=document.createElement('div');
      el.className='confetti-piece';
      el.style.left=Math.random()*100+'vw';
      el.style.background=BLOB_COLORS[Math.floor(Math.random()*BLOB_COLORS.length)];
      el.style.animationDuration=(1+Math.random()*2)+'s';
      el.style.animationDelay=(Math.random()*0.5)+'s';
      el.style.transform=`rotate(${Math.random()*360}deg)`;
      el.style.width=el.style.height=(6+Math.random()*10)+'px';
      document.body.appendChild(el);
      setTimeout(()=>el.remove(),3000);
    },i*30);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  BOOT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
initTitle();
myColor = Math.floor(Math.random()*BLOB_COLORS.length);

// roundRect polyfill
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x,y,w,h,r){
    this.moveTo(x+r,y);
    this.lineTo(x+w-r,y); this.arcTo(x+w,y,x+w,y+r,r);
    this.lineTo(x+w,y+h-r); this.arcTo(x+w,y+h,x+w-r,y+h,r);
    this.lineTo(x+r,y+h); this.arcTo(x,y+h,x,y+h-r,r);
    this.lineTo(x,y+r); this.arcTo(x,y,x+r,y,r);
    this.closePath();
    return this;
  };
}
</script>
</body>
</html>